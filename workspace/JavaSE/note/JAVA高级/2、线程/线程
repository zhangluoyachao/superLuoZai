一、线程
1、进程：一个应用程序执行过程，包含了程序所持有的资源
        一般情况下，一个应用程序对应一个进程
2、线程：进程就是线程的集合，它是一个应用程序执行的某项任务，一个进程包含了无数个线程
3、多线程并发：并不是说多个线程同时执行，代表多个线程同时交替抢占CPU资源
             为了提高CPU的效率 为了更好的用户体验

二、线程的实现方式
1、java中实现线程的方式有三种：
    1.1、继承Thread（线程）类，重写run()方法
    1.2、实现Runnable接口，重写run方法 不是线程，只是线程的实现逻辑
        需要线程去承载逻辑：
        Runnable1 run = new Runnable1();
        Thread t = new Thread(run);
    1.3、利用线程池：存放线程的空间，里面存放多个线程。节省了创建线程的时间，增加了空间。
         是一种以空间换时间的方式提高效率

三、使用线程的步骤
1、定义线程
//实现线程第一种方法:继承Thread（线程）类，重写run()方法
class MyThread extends Thread {
    @Override
    public void run() {
        //获取线程名称  一般是线程对象调用getName()
        //线程中则获取当前线程
        Thread t = Thread.currentThread();//获取当前线程
        System.out.println("我是一个线程,名称是："+t.getName());
    }
}

//实现线程的第二种方式：实现Runnable接口，重写Run方法
class MyRunnable implements Runnable {
    @Override
    public void run() {
        Thread t = Thread.currentThread();
        System.out.println("我是另一个线程名称是："+t.getName());
    }
}

2、创建线程对象
    第一种：
    MyThread myT = new MyThread();

    //命名
    myT.setName("线程1");
    //或者直接命名
    MyThread myT = new MyThread("线程1");

    第二种：
    MyRunnable myR = new MyRunnable();//线程的实现逻辑
    Thread myT2 = new Thread(myR);

    //命名
    myT2.setName("线程2");
    //或者直接命名
    Thread myT2 = new Thread(myR,"线程2");

3、启动线程
    3.1、start()
        myT.start();
        myT2.start();
    3.2、run()
        myT.run();
        myT2.run();
    3.3、run和start的区别：
        run：表示只有一个主线程去执行  类似于方法调用，顺序执行
        start：表示多个线程执行，主线程和子线程交替执行

4、终止线程
    会自动关闭

四、线程中常用的方法
1、currentThread()：Thread类的静态方法，表示获取当前线程
2、start():启动一个线程，表示线程进入就绪状态，后面执行需要抢占CPU,抢到了就会进行执行状态
   run():表示线程的执行过程,不会开启线程，只是在主线程上运行run方法 类似于方法的调用
         a.只要线程抢到了CPU就会自动执行run()
         b.run()执行结束 线程死亡
两者区别：
   run：表示只有一个主线程去执行  类似于方法调用，顺序执行
   start：表示多个线程执行，主线程和子线程交替执行
3、setName():用于设置线程名称
   getName():用于获取线程名称
4、sleep(time): 线程休眠，进入阻塞状态，time为毫秒数
        a.Thread类的静态方法，表示让线程进入休眠，会出现检查性异常。
        b.如果休眠时间到了，会直接进入就绪状态,。
        c.执行了休眠会放弃本次CPU执行权
        d.不会释放对象锁
   wait():是object方法，效果类似sleep
        a.使线程之间进入阻塞状态
        b.会释放对象锁
        c.调用了wait()的线程不唤醒会一直处于阻塞状态
        d.唤醒的方法：notify()和notifyAll()    object方法
               1、notify()   唤醒一个处于等待的线程
               2、notifyAll()    唤醒所有处于等待的线程
5、setPriority(): 设置线程优先级1-10，默认为5，值越高，有限制越高
                  当多个线程同一个时间节点抢CPU时会触发优先级，优先级高的获取CPU执行权
6、yield:放弃当前CPU执行权，进入就绪状态（还可能下次CPU执行全还被抢），没啥用
7、t.join(): t是一个线程，等待t线程执行结束后，才能执行当前线程
8、isAlive(): 判断线程是否存活

sleep、wait、join 使用时都会出现检查性异常：线程终止异常InterruptedException

五、线程的五大状态
1、新建状态（创建状态）：
    用new创建线程时： new Thread(); 此时线程处于创建状态
2、就绪状态：
    一般情况下，一个新建状态下的线程不会自动开始，需要调用start方法开启线程，进入就绪状态。
    启动之后并不会立刻执行，需要和其他线程抢占CPU才会进入运行状态。
3、运行状态：
    当就绪状体的线程抢到CPU后，就会进入运行状态，执行其run()方法
4、阻塞状态：
    当线程运行过程中，可能由于各种原因进入阻塞状态。
        原因:
            a.线程调用sleep方法
            b.线程调用wait方法，等待唤醒条件触发
            c.线程如果得到锁，而该锁正在被其他线程锁持有，其他线程如果不释放锁，
            该线程会一直处于阻塞状态
            d.线程调用了IO操作，会被阻塞。
            因为该操作需要输入输出，如果不输入输出，则会一直处于阻塞状态。
            类似与Scanner手动输入
    总结：线程处于阻塞状态时，当前的线程并没有结束，只是暂时让出CPU，等待再次进入就绪状态。
5、死亡状态：
    a.run()方法正常执行结束，自然死亡
    b.当执行线程时出现异常，导致线程终止run()方法，非自然死亡。
    c.interrupt()方法 中断线程

六、线程同步 难点
线程同步的关键词：synchronized
1、线程同步：
       多个线程操作 同一个数据 时，为了保证数据前后准确，需要在实现线程时，
       给数据添加对象锁，当有一个线程操作该数据同时也会锁住该数据。
       其他线程是不能够对该数据做修改，只有释放了该数据的对象锁，其他线程才能对数据进行访问。
   实现方式：
        1、保证数据共享
        2、给共享数据上对象锁
   目的：
       保证多个线程数据共享，确保数据准确性，一致性
2、线程安全：程序无论是在单线程和多线程的程序，他们运行过程中，数据永远是一致的
         运行途中属性不会和开始出现差异（实现了同步锁的线程）
3、线程同步：
    1、同步代码块    synchronized修饰的代码块
    2、同步方法     synchronized修饰的方法

        a.代码块：
        synchronized(a对象){   当线程运行到此处时，会锁住a对象，(对象可以是有关也可以是无关的)
                               其他线程无法访问，需要等待其释放对象锁
            同步代码
            a.notifyAll();    唤醒其他线程（如果之前没有阻塞线程可以不用）
            a.wait();       主动释放锁，其之前绑定的线程进入阻塞状态，其他线程可以进行访问
        注：不能用this调用而是用a调用 表示拥有a对象的线程   如果锁住的是this可以默认不写
        }
        同步代码块中的代码执行完毕，自动释放锁，之前线程也处于就绪状态，可以继续挣抢cpu访问a对象

        b.方法：
            1、非静态
                public synchronized void test(){}  同步方法  锁的是当前对象(this)
                ==>
                synchronized(this){}
            都属于对象锁
            2、静态
                public synchronized void test(){}   静态同步方法  锁的是当前类
                ==>
                synchronized(Test.class){}
            都属于类锁

    对象锁和类锁无关，可以同时执行

七、线程死锁
当多个线程相互持有对方的锁标记，双方都会需要对方释放锁标记，但是两边都堵塞无法释放，导致死锁。
1、避免死锁：编程的时候，尽量避免线程多个锁，如果避免不了，尽可能让每一个线程持有锁的时间缩短

八、线程池   面试题
1、线程池：可以节省创建线程的时间，提高速度，
         在线程池中事先创建很多个线程，每次使用时只需要调用即可。
         以空间换时间的方式，提高效率
2、分类：
    a.可缓存线程池：
    b.定长线程池：
    c.周期定长线程池：
    d.单线程池：
线程池父类：ExecutorService
线程池的工具类：Executors 用于创建工具类